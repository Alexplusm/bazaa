TODO: подсчет активныйх пользователей определенных extSystems (на уровне редиса?)

TODO:  Везде unix-timestamp !!!

## Config
Количество оценок пользователей, достаточной для финальной оценки = 10

Таймаут

## Создание игры

Используем форму админки (FRONT)
1) Вводим основную информацию об игре (Форма создания игры)
    * название
    * даты: начало-конец
    * вопрос
    * тип ответов
    * опции ответа (если выбран тип "категориальный") 
2) -> попадаем в список игр (каким либо способом отсортированным? возможности сортировок?)
3) Кликаем на только что созданную игру
4) Попадает на страницу игры с информацией (ранее введенной)
5) На этой странице есть возможности добавить к игре скриншоты
    * Загрузить расписание
    * Передать список schedulesID 
        * (BACK) Нужен метод, который возвращает список schedulesID (TODO)
        * (BACK) По способу добавления скриншота (архив/расписания) вычисляем sourceID
        * (BACK) При загрузке с файла, пытаемся сразу прописать expert_answer в поле скриншота (судя по файловой структуре)
        * (BACK) При загрузке расписаний - schedule_id -> source_id
        * (BACK) При загрузке расписаний - schedule_date -> source_created_at 
BACK METHODS:
* POST create game
* PUT update game
QUESTIONS:
1) Мы как нибудь связываем ИГРУ и EXT_SYSTEM ?
    * при отдаче списка игры в query_params присутствует ext_system_id
    * при создании игры никак не фигурирует ext_system_id

## Список игр
Отдаем список игр

## Подробная информация об игре
Отдаем подробную информацию об игре (с информацией об источниках скриншотов)

## Перед игрой прогреваем redis!
TODO
* заранее закидываем фэйковые задания из прошлой игры с таким же answerType
    * фэйковое задание - то, у которого есть expertAnswer 
        *(QUESTION) как клиент поймет, что задание фэйковое? в методе по отдаче задания никакое поле за это не отвечает
    *(QUESTION) сколько кэшировать заданий? (10% ? TODO: в конфиг вынести)
## Получение новой задачи пользователем
* каждую задачу отдаем десятерым пользователям
* 


## Активные пользователи
* Фиксируем ?массив {userId: id, lastActivity: timestamp}
    * либо на уровне redis создать несколько database, тогда ключом там будет "userId"
* Обновляем lastActivity при каждом полученном ответе от пользователя
* когда просят активных пользователей
    * возвращаем пользователей, который были активны последние N минут (10-15 min | Выносим в конфиг)